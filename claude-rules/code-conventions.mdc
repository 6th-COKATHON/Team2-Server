---
alwaysApply: true
---

# Code Conventions & Style Rules

## ğŸ¯ MANDATORY CODING STANDARDS

### âœ… MUST DO - Java Code Style

**1. Class Structure Order:**
```java
public class UserService {
    // 1. Static constants (UPPER_SNAKE_CASE)
    private static final String DEFAULT_ROLE = "USER";
    
    // 2. Instance fields (private, final when possible)
    private final UserEntityRepository userRepository;
    private final BCryptPasswordEncoder passwordEncoder;
    
    // 3. Constructor (with @RequiredArgsConstructor or manual)
    public UserService(UserEntityRepository userRepository, 
                      BCryptPasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }
    
    // 4. Public methods
    public UserCreateResponse createUser(String email, String password, String name) {
        // Implementation
    }
    
    // 5. Private methods
    private void validateUserData(String email) {
        // Implementation
    }
}
```

**2. Method Naming Patterns:**
- **Create**: `create[Entity]`, `register[Entity]`
- **Read**: `get[Entity]`, `find[Entity]`, `search[Entity]`
- **Update**: `update[Entity]`, `modify[Entity]`
- **Delete**: `delete[Entity]`, `remove[Entity]`
- **Validation**: `validate[Field]`, `check[Condition]`
- **Business Logic**: `process[Action]`, `handle[Event]`

**3. Variable Naming:**
```java
// âœ… GOOD
private final UserEntityRepository userEntityRepository;
private final BCryptPasswordEncoder passwordEncoder;
private final String accessToken;
private final List<PostEntity> userPosts;

// âŒ BAD
private final UserEntityRepository repo;
private final BCryptPasswordEncoder encoder;
private final String token;
private final List<PostEntity> posts;
```

### âŒ NEVER DO - Code Style Violations

1. **NEVER** use single-letter variables except for loops
2. **NEVER** use abbreviations in class/method names
3. **NEVER** create methods longer than 50 lines
4. **NEVER** use Hungarian notation
5. **NEVER** mix camelCase and snake_case
6. **NEVER** use magic numbers without constants

## ğŸ—ï¸ MANDATORY LOMBOK USAGE

### âœ… MUST DO - Lombok Patterns

**Entities:**
```java
@Entity
@Table(name = "users")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Builder
public class UserEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String email;
    
    // Use @Builder for construction
    @Builder
    private UserEntity(String email, String password, String name) {
        this.email = email;
        this.password = password;
        this.name = name;
    }
}
```

**Services:**
```java
@Service
@RequiredArgsConstructor  // ALWAYS use for dependency injection
@Slf4j                    // For logging
public class UserService {
    private final UserEntityRepository userRepository;
    
    public void logUserAction(String action) {
        log.info("User action: {}", action);  // Use log, not System.out
    }
}
```

**DTOs (Records):**
```java
// âœ… PREFERRED: Use Java 17 Records
public record UserCreateRequest(
    @Email(message = "ì´ë©”ì¼ í˜•ì‹ìœ¼ë¡œ ìš”ì²­í•´ì£¼ì„¸ìš”.")
    @NotBlank(message = "ì´ë©”ì¼ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    String email,
    
    @NotBlank(message = "ì´ë¦„ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    @Length(min = 1, max = 20, message = "ì´ë¦„ì€ 2ì ì´ìƒ 20ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    String name,
    
    @Password(message = "ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒ 20ì ì´í•˜, ì˜ë¬¸, ìˆ«ì, íŠ¹ìˆ˜ë¬¸ìë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.")
    String password
) {
    // Static factory methods if needed
    public static UserCreateRequest of(String email, String name, String password) {
        return new UserCreateRequest(email, name, password);
    }
}
```

### âŒ NEVER DO - Lombok Violations

1. **NEVER** use `@Data` on entities (use `@Getter` only)
2. **NEVER** use `@AllArgsConstructor` on entities
3. **NEVER** use `@Setter` on entities (use builder pattern)
4. **NEVER** use `@ToString` on entities with relationships
5. **NEVER** use `@EqualsAndHashCode` without understanding implications

## ğŸ”§ MANDATORY ANNOTATION USAGE

### âœ… MUST DO - Spring Annotations

**Controllers:**
```java
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
@Slf4j
public class UserController {
    
    @PostMapping
    @Operation(summary = "íšŒì›ê°€ì… API", description = "ìƒì„¸ ì„¤ëª…")
    @ApiResponse(responseCode = "400", description = "ì‚¬ìš©ì ì…ë ¥ ì˜¤ë¥˜[C-001]")
    public ResponseEntity<AppResponse<UserCreateResponse>> createUser(
        @RequestBody @Valid UserCreateRequest request) {
        // Implementation
    }
}
```

**Services:**
```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)  // Default to read-only
public class UserService {
    
    @Transactional  // Override for write operations
    public UserCreateResponse createUser(String email, String password, String name) {
        // Implementation
    }
}
```

**Validation:**
```java
// âœ… ALWAYS use validation annotations
@NotBlank(message = "í•„ë“œëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤.")
@Email(message = "ì´ë©”ì¼ í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
@Length(min = 1, max = 50, message = "1ì ì´ìƒ 50ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
@Pattern(regexp = "^[a-zA-Z0-9]*$", message = "ì˜ë¬¸ê³¼ ìˆ«ìë§Œ ì…ë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
```

### âŒ NEVER DO - Annotation Violations

1. **NEVER** use `@Autowired` (use constructor injection)
2. **NEVER** forget `@Valid` on request DTOs
3. **NEVER** use `@Transactional` on controllers
4. **NEVER** use `@RequestParam` for complex objects
5. **NEVER** forget validation messages in Korean

## ğŸ¯ MANDATORY EXCEPTION HANDLING

### âœ… MUST DO - Exception Patterns

**Custom Exceptions:**
```java
// âœ… ALWAYS use AppException with ErrorCode
public void validateUser(String email) {
    if (userRepository.existsByEmail(email)) {
        throw new AppException(ErrorCode.USER_EMAIL_DUPLICATED_EXCEPTION);
    }
}

// âœ… ALWAYS provide context in error messages
public UserEntity findUserById(Long id) {
    return userRepository.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.USER_NOT_FOUND_EXCEPTION));
}
```

**Error Codes:**
```java
// âœ… FOLLOW this pattern: [DOMAIN_PREFIX]-[NUMBER]
USER_NOT_FOUND_EXCEPTION(HttpStatus.NOT_FOUND, "U-002", "í•´ë‹¹ ìœ ì €ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."),
POST_NOT_FOUND_EXCEPTION(HttpStatus.NOT_FOUND, "P-001", "í•´ë‹¹ í¬ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."),
```

### âŒ NEVER DO - Exception Violations

1. **NEVER** catch and ignore exceptions
2. **NEVER** use generic Exception types
3. **NEVER** return null (use Optional or throw exception)
4. **NEVER** use English in error messages
5. **NEVER** log exceptions in service layer (let global handler do it)

## ğŸ” MANDATORY DOCUMENTATION

### âœ… MUST DO - Code Documentation

**API Documentation:**
```java
@Operation(
    summary = "íšŒì›ê°€ì… API",
    description = "ì´ë©”ì¼, ë¹„ë°€ë²ˆí˜¸, ì´ë¦„ì„ ì…ë ¥í•˜ì—¬ íšŒì›ê°€ì…ì„ ì§„í–‰í•©ë‹ˆë‹¤.",
    responses = {
        @ApiResponse(responseCode = "201", description = "íšŒì›ê°€ì… ì„±ê³µ"),
        @ApiResponse(responseCode = "400", description = "ì‚¬ìš©ì ì…ë ¥ ì˜¤ë¥˜[C-001]"),
        @ApiResponse(responseCode = "409", description = "ì´ë¯¸ ì‚¬ìš©ì¤‘ì¸ ì´ë©”ì¼ì…ë‹ˆë‹¤.[U-001]")
    }
)
```

**Method Documentation:**
```java
/**
 * ì‚¬ìš©ì íšŒì›ê°€ì… ì²˜ë¦¬
 * 
 * @param email ì‚¬ìš©ì ì´ë©”ì¼ (ìœ íš¨ì„± ê²€ì¦ í•„ìš”)
 * @param password ì•”í˜¸í™”ë˜ì§€ ì•Šì€ ë¹„ë°€ë²ˆí˜¸
 * @param name ì‚¬ìš©ì ì´ë¦„
 * @return ìƒì„±ëœ ì‚¬ìš©ì ì •ë³´
 * @throws AppException ì´ë©”ì¼ ì¤‘ë³µ ì‹œ USER_EMAIL_DUPLICATED_EXCEPTION
 */
@Transactional
public UserCreateResponse createUser(String email, String password, String name) {
    // Implementation
}
```

### âŒ NEVER DO - Documentation Violations

1. **NEVER** leave public methods without documentation
2. **NEVER** use English in user-facing messages
3. **NEVER** forget to update documentation when changing code
4. **NEVER** use TODO comments in production code

## ğŸš¨ CRITICAL CODE QUALITY RULES

### âœ… MUST DO - Quality Assurance

1. **ALWAYS** use meaningful variable names
2. **ALWAYS** validate input parameters
3. **ALWAYS** use appropriate data types
4. **ALWAYS** handle edge cases
5. **ALWAYS** follow single responsibility principle
6. **ALWAYS** use immutable objects when possible
7. **ALWAYS** prefer composition over inheritance

### âŒ NEVER DO - Quality Violations

1. **NEVER** use System.out.println (use logging)
2. **NEVER** hardcode sensitive information
3. **NEVER** create God classes (>500 lines)
4. **NEVER** use reflection without good reason
5. **NEVER** ignore compiler warnings
6. **NEVER** commit commented-out code
7. **NEVER** use deprecated APIs

## ğŸ”§ CODE FORMATTING RULES

### âœ… MUST DO - Formatting Standards

```java
// âœ… Method parameters (one per line if >3 params)
public ResponseEntity<AppResponse<UserCreateResponse>> createUser(
    @RequestBody @Valid UserCreateRequest request,
    @CurrentUser UserEntity currentUser,
    HttpServletRequest httpRequest) {
    
    // âœ… Chain method calls
    return userRepository.findByEmail(email)
        .map(this::convertToResponse)
        .orElseThrow(() -> new AppException(ErrorCode.USER_NOT_FOUND_EXCEPTION));
}

// âœ… Complex conditionals
if (user.isActive() 
    && user.hasPermission(Permission.WRITE)
    && !user.isExpired()) {
    // Implementation
}
```

### âŒ NEVER DO - Formatting Violations

1. **NEVER** exceed 120 characters per line
2. **NEVER** use tabs (use 4 spaces)
3. **NEVER** leave trailing whitespace
4. **NEVER** mix different indentation styles
5. **NEVER** skip empty lines between logical blocks

Remember: **Code is read more often than it's written**. Make it readable and maintainable!
# Code Conventions & Style Rules

## ğŸ¯ MANDATORY CODING STANDARDS

### âœ… MUST DO - Java Code Style

**1. Class Structure Order:**
```java
public class UserService {
    // 1. Static constants (UPPER_SNAKE_CASE)
    private static final String DEFAULT_ROLE = "USER";
    
    // 2. Instance fields (private, final when possible)
    private final UserEntityRepository userRepository;
    private final BCryptPasswordEncoder passwordEncoder;
    
    // 3. Constructor (with @RequiredArgsConstructor or manual)
    public UserService(UserEntityRepository userRepository, 
                      BCryptPasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.passwordEncoder = passwordEncoder;
    }
    
    // 4. Public methods
    public UserCreateResponse createUser(String email, String password, String name) {
        // Implementation
    }
    
    // 5. Private methods
    private void validateUserData(String email) {
        // Implementation
    }
}
```

**2. Method Naming Patterns:**
- **Create**: `create[Entity]`, `register[Entity]`
- **Read**: `get[Entity]`, `find[Entity]`, `search[Entity]`
- **Update**: `update[Entity]`, `modify[Entity]`
- **Delete**: `delete[Entity]`, `remove[Entity]`
- **Validation**: `validate[Field]`, `check[Condition]`
- **Business Logic**: `process[Action]`, `handle[Event]`

**3. Variable Naming:**
```java
// âœ… GOOD
private final UserEntityRepository userEntityRepository;
private final BCryptPasswordEncoder passwordEncoder;
private final String accessToken;
private final List<PostEntity> userPosts;

// âŒ BAD
private final UserEntityRepository repo;
private final BCryptPasswordEncoder encoder;
private final String token;
private final List<PostEntity> posts;
```

### âŒ NEVER DO - Code Style Violations

1. **NEVER** use single-letter variables except for loops
2. **NEVER** use abbreviations in class/method names
3. **NEVER** create methods longer than 50 lines
4. **NEVER** use Hungarian notation
5. **NEVER** mix camelCase and snake_case
6. **NEVER** use magic numbers without constants

## ğŸ—ï¸ MANDATORY LOMBOK USAGE

### âœ… MUST DO - Lombok Patterns

**Entities:**
```java
@Entity
@Table(name = "users")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Builder
public class UserEntity extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true, nullable = false)
    private String email;
    
    // Use @Builder for construction
    @Builder
    private UserEntity(String email, String password, String name) {
        this.email = email;
        this.password = password;
        this.name = name;
    }
}
```

**Services:**
```java
@Service
@RequiredArgsConstructor  // ALWAYS use for dependency injection
@Slf4j                    // For logging
public class UserService {
    private final UserEntityRepository userRepository;
    
    public void logUserAction(String action) {
        log.info("User action: {}", action);  // Use log, not System.out
    }
}
```

**DTOs (Records):**
```java
// âœ… PREFERRED: Use Java 17 Records
public record UserCreateRequest(
    @Email(message = "ì´ë©”ì¼ í˜•ì‹ìœ¼ë¡œ ìš”ì²­í•´ì£¼ì„¸ìš”.")
    @NotBlank(message = "ì´ë©”ì¼ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    String email,
    
    @NotBlank(message = "ì´ë¦„ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    @Length(min = 1, max = 20, message = "ì´ë¦„ì€ 2ì ì´ìƒ 20ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    String name,
    
    @Password(message = "ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒ 20ì ì´í•˜, ì˜ë¬¸, ìˆ«ì, íŠ¹ìˆ˜ë¬¸ìë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.")
    String password
) {
    // Static factory methods if needed
    public static UserCreateRequest of(String email, String name, String password) {
        return new UserCreateRequest(email, name, password);
    }
}
```

### âŒ NEVER DO - Lombok Violations

1. **NEVER** use `@Data` on entities (use `@Getter` only)
2. **NEVER** use `@AllArgsConstructor` on entities
3. **NEVER** use `@Setter` on entities (use builder pattern)
4. **NEVER** use `@ToString` on entities with relationships
5. **NEVER** use `@EqualsAndHashCode` without understanding implications

## ğŸ”§ MANDATORY ANNOTATION USAGE

### âœ… MUST DO - Spring Annotations

**Controllers:**
```java
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
@Slf4j
public class UserController {
    
    @PostMapping
    @Operation(summary = "íšŒì›ê°€ì… API", description = "ìƒì„¸ ì„¤ëª…")
    @ApiResponse(responseCode = "400", description = "ì‚¬ìš©ì ì…ë ¥ ì˜¤ë¥˜[C-001]")
    public ResponseEntity<AppResponse<UserCreateResponse>> createUser(
        @RequestBody @Valid UserCreateRequest request) {
        // Implementation
    }
}
```

**Services:**
```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)  // Default to read-only
public class UserService {
    
    @Transactional  // Override for write operations
    public UserCreateResponse createUser(String email, String password, String name) {
        // Implementation
    }
}
```

**Validation:**
```java
// âœ… ALWAYS use validation annotations
@NotBlank(message = "í•„ë“œëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤.")
@Email(message = "ì´ë©”ì¼ í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
@Length(min = 1, max = 50, message = "1ì ì´ìƒ 50ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
@Pattern(regexp = "^[a-zA-Z0-9]*$", message = "ì˜ë¬¸ê³¼ ìˆ«ìë§Œ ì…ë ¥ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
```

### âŒ NEVER DO - Annotation Violations

1. **NEVER** use `@Autowired` (use constructor injection)
2. **NEVER** forget `@Valid` on request DTOs
3. **NEVER** use `@Transactional` on controllers
4. **NEVER** use `@RequestParam` for complex objects
5. **NEVER** forget validation messages in Korean

## ğŸ¯ MANDATORY EXCEPTION HANDLING

### âœ… MUST DO - Exception Patterns

**Custom Exceptions:**
```java
// âœ… ALWAYS use AppException with ErrorCode
public void validateUser(String email) {
    if (userRepository.existsByEmail(email)) {
        throw new AppException(ErrorCode.USER_EMAIL_DUPLICATED_EXCEPTION);
    }
}

// âœ… ALWAYS provide context in error messages
public UserEntity findUserById(Long id) {
    return userRepository.findById(id)
        .orElseThrow(() -> new AppException(ErrorCode.USER_NOT_FOUND_EXCEPTION));
}
```

**Error Codes:**
```java
// âœ… FOLLOW this pattern: [DOMAIN_PREFIX]-[NUMBER]
USER_NOT_FOUND_EXCEPTION(HttpStatus.NOT_FOUND, "U-002", "í•´ë‹¹ ìœ ì €ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."),
POST_NOT_FOUND_EXCEPTION(HttpStatus.NOT_FOUND, "P-001", "í•´ë‹¹ í¬ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."),
```

### âŒ NEVER DO - Exception Violations

1. **NEVER** catch and ignore exceptions
2. **NEVER** use generic Exception types
3. **NEVER** return null (use Optional or throw exception)
4. **NEVER** use English in error messages
5. **NEVER** log exceptions in service layer (let global handler do it)

## ğŸ” MANDATORY DOCUMENTATION

### âœ… MUST DO - Code Documentation

**API Documentation:**
```java
@Operation(
    summary = "íšŒì›ê°€ì… API",
    description = "ì´ë©”ì¼, ë¹„ë°€ë²ˆí˜¸, ì´ë¦„ì„ ì…ë ¥í•˜ì—¬ íšŒì›ê°€ì…ì„ ì§„í–‰í•©ë‹ˆë‹¤.",
    responses = {
        @ApiResponse(responseCode = "201", description = "íšŒì›ê°€ì… ì„±ê³µ"),
        @ApiResponse(responseCode = "400", description = "ì‚¬ìš©ì ì…ë ¥ ì˜¤ë¥˜[C-001]"),
        @ApiResponse(responseCode = "409", description = "ì´ë¯¸ ì‚¬ìš©ì¤‘ì¸ ì´ë©”ì¼ì…ë‹ˆë‹¤.[U-001]")
    }
)
```

**Method Documentation:**
```java
/**
 * ì‚¬ìš©ì íšŒì›ê°€ì… ì²˜ë¦¬
 * 
 * @param email ì‚¬ìš©ì ì´ë©”ì¼ (ìœ íš¨ì„± ê²€ì¦ í•„ìš”)
 * @param password ì•”í˜¸í™”ë˜ì§€ ì•Šì€ ë¹„ë°€ë²ˆí˜¸
 * @param name ì‚¬ìš©ì ì´ë¦„
 * @return ìƒì„±ëœ ì‚¬ìš©ì ì •ë³´
 * @throws AppException ì´ë©”ì¼ ì¤‘ë³µ ì‹œ USER_EMAIL_DUPLICATED_EXCEPTION
 */
@Transactional
public UserCreateResponse createUser(String email, String password, String name) {
    // Implementation
}
```

### âŒ NEVER DO - Documentation Violations

1. **NEVER** leave public methods without documentation
2. **NEVER** use English in user-facing messages
3. **NEVER** forget to update documentation when changing code
4. **NEVER** use TODO comments in production code

## ğŸš¨ CRITICAL CODE QUALITY RULES

### âœ… MUST DO - Quality Assurance

1. **ALWAYS** use meaningful variable names
2. **ALWAYS** validate input parameters
3. **ALWAYS** use appropriate data types
4. **ALWAYS** handle edge cases
5. **ALWAYS** follow single responsibility principle
6. **ALWAYS** use immutable objects when possible
7. **ALWAYS** prefer composition over inheritance

### âŒ NEVER DO - Quality Violations

1. **NEVER** use System.out.println (use logging)
2. **NEVER** hardcode sensitive information
3. **NEVER** create God classes (>500 lines)
4. **NEVER** use reflection without good reason
5. **NEVER** ignore compiler warnings
6. **NEVER** commit commented-out code
7. **NEVER** use deprecated APIs

## ğŸ”§ CODE FORMATTING RULES

### âœ… MUST DO - Formatting Standards

```java
// âœ… Method parameters (one per line if >3 params)
public ResponseEntity<AppResponse<UserCreateResponse>> createUser(
    @RequestBody @Valid UserCreateRequest request,
    @CurrentUser UserEntity currentUser,
    HttpServletRequest httpRequest) {
    
    // âœ… Chain method calls
    return userRepository.findByEmail(email)
        .map(this::convertToResponse)
        .orElseThrow(() -> new AppException(ErrorCode.USER_NOT_FOUND_EXCEPTION));
}

// âœ… Complex conditionals
if (user.isActive() 
    && user.hasPermission(Permission.WRITE)
    && !user.isExpired()) {
    // Implementation
}
```

### âŒ NEVER DO - Formatting Violations

1. **NEVER** exceed 120 characters per line
2. **NEVER** use tabs (use 4 spaces)
3. **NEVER** leave trailing whitespace
4. **NEVER** mix different indentation styles
5. **NEVER** skip empty lines between logical blocks

Remember: **Code is read more often than it's written**. Make it readable and maintainable!


### ğŸš¨ **CRITICAL: PRESERVE EXISTING CODE FORMATTING**

**When making changes to existing code, you MUST preserve the original formatting style:**

```java
// âŒ NEVER change existing formatting unless specifically requested
// Original code:
AppException exception = assertThrows(AppException.class, () ->
  aiImageGenerationService.createAiImageGetUrl(TEST_REQUEST_ID, TEST_USER_ID));

// âŒ DO NOT "improve" it to:
AppException exception = assertThrows(AppException.class, 
  () -> aiImageGenerationService.someMethod(param));

// âœ… KEEP the original formatting intact
AppException exception = assertThrows(AppException.class, () ->
  aiImageGenerationService.createAiImageGetUrl(TEST_REQUEST_ID, TEST_USER_ID));
```

**Formatting Preservation Rules:**
1. **NEVER** change indentation style of existing code
2. **NEVER** change line breaking patterns of existing code  
3. **NEVER** change bracket placement of existing code
4. **NEVER** change parameter alignment of existing code
5. **ONLY** apply formatting changes when explicitly requested by user
6. **ONLY** format new code you add, not existing code you touch

**Exception:** Only change formatting if:
- User explicitly requests formatting changes
- The existing formatting violates critical readability (> 200 chars per line)
- You're doing a dedicated formatting/refactoring task

### âœ… MUST DO - Java Code Style

**1. Class Structure Order:** 