---
alwaysApply: true
---

# Testing Standards & Best Practices

## ğŸ§ª MANDATORY TESTING STRUCTURE

### âœ… MUST DO - Test Organization

**Test Package Structure:**
```
src/test/java/
â”œâ”€â”€ base/                           # Test utilities and base classes
â”‚   â”œâ”€â”€ BaseIntegrationTest.java   # Integration test base
â”‚   â”œâ”€â”€ BaseControllerTest.java    # Controller test base
â”‚   â”œâ”€â”€ TestUtil.java              # Test utilities
â”‚   â””â”€â”€ DatabaseCleanUp.java       # Database cleanup
â”œâ”€â”€ domain/                         # Domain layer tests
â”‚   â””â”€â”€ [domain]/
â”‚       â”œâ”€â”€ service/               # Service unit tests
â”‚       â”œâ”€â”€ repository/            # Repository integration tests
â”‚       â””â”€â”€ entityfactory/         # Test data factories
â””â”€â”€ web/                           # Web layer tests
    â””â”€â”€ [domain]/
        â””â”€â”€ controller/            # Controller integration tests
```

**Test Class Naming:**
- **Unit Tests**: `[ClassName]Test.java`
- **Integration Tests**: `[ClassName]IntegrationTest.java`
- **Controller Tests**: `[ClassName]ControllerTest.java`

### âœ… MUST DO - Test Method Naming

**Pattern**: `[methodName]_[scenario]_[expectedResult]`

```java
// âœ… GOOD Examples
@Test
@DisplayName("íšŒì›ê°€ì… ì„±ê³µ - ìœ íš¨í•œ ë°ì´í„°")
void createUser_ValidData_ShouldReturnUserCreateResponse() {
    // Test implementation
}

@Test
@DisplayName("íšŒì›ê°€ì… ì‹¤íŒ¨ - ì´ë©”ì¼ ì¤‘ë³µ")
void createUser_DuplicateEmail_ShouldThrowAppException() {
    // Test implementation
}

@Test
@DisplayName("ì‚¬ìš©ì ì¡°íšŒ ì‹¤íŒ¨ - ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ID")
void getUserById_NonExistentId_ShouldThrowUserNotFoundException() {
    // Test implementation
}
```

### âŒ NEVER DO - Test Structure Violations

1. **NEVER** put test classes in src/main/java
2. **NEVER** create tests without proper package structure
3. **NEVER** use generic test method names like `test1()`, `testMethod()`
4. **NEVER** skip `@DisplayName` annotation
5. **NEVER** mix different types of tests in the same class

## ğŸ¯ MANDATORY UNIT TESTING PATTERNS

### âœ… MUST DO - Service Layer Testing

```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @InjectMocks
    private UserService userService;
    
    @Mock
    private UserEntityRepository userRepository;
    
    @Mock
    private BCryptPasswordEncoder passwordEncoder;
    
    @Test
    @DisplayName("íšŒì›ê°€ì… ì„±ê³µ")
    void createUser_ValidData_ShouldReturnUserCreateResponse() {
        // given
        String email = "test@example.com";
        String password = "password123!";
        String name = "Test User";
        
        when(userRepository.existsByEmail(email)).thenReturn(false);
        when(passwordEncoder.encode(password)).thenReturn("encodedPassword");
        
        // when
        UserCreateResponse result = userService.createUser(email, password, name);
        
        // then
        assertThat(result).isNotNull();
        assertThat(result.email()).isEqualTo(email);
        assertThat(result.name()).isEqualTo(name);
        
        verify(userRepository).existsByEmail(email);
        verify(passwordEncoder).encode(password);
        verify(userRepository).save(any(UserEntity.class));
    }
    
    @Test
    @DisplayName("íšŒì›ê°€ì… ì‹¤íŒ¨ - ì´ë©”ì¼ ì¤‘ë³µ")
    void createUser_DuplicateEmail_ShouldThrowAppException() {
        // given
        String email = "duplicate@example.com";
        String password = "password123!";
        String name = "Test User";
        
        when(userRepository.existsByEmail(email)).thenReturn(true);
        
        // when & then
        AppException exception = assertThrows(AppException.class, 
            () -> userService.createUser(email, password, name));
        
        assertThat(exception.getErrorCode()).isEqualTo(ErrorCode.USER_EMAIL_DUPLICATED_EXCEPTION);
        
        verify(userRepository).existsByEmail(email);
        verify(passwordEncoder, never()).encode(any());
        verify(userRepository, never()).save(any());
    }
}
```

### âœ… MUST DO - Repository Testing

```java
@DataJpaTest
class UserEntityRepositoryTest {
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Autowired
    private UserEntityRepository userRepository;
    
    @Test
    @DisplayName("ì´ë©”ì¼ë¡œ ì‚¬ìš©ì ì¡°íšŒ ì„±ê³µ")
    void findByEmail_ExistingEmail_ShouldReturnUser() {
        // given
        UserEntity user = UserEntity.builder()
            .email("test@example.com")
            .password("password")
            .name("Test User")
            .build();
        entityManager.persistAndFlush(user);
        
        // when
        Optional<UserEntity> result = userRepository.findByEmail("test@example.com");
        
        // then
        assertThat(result).isPresent();
        assertThat(result.get().getEmail()).isEqualTo("test@example.com");
    }
}
```

### âŒ NEVER DO - Unit Test Violations

1. **NEVER** use real database in unit tests
2. **NEVER** test multiple scenarios in one test method
3. **NEVER** use `@SpringBootTest` for unit tests
4. **NEVER** ignore test failures
5. **NEVER** create tests without assertions

## ğŸŒ MANDATORY INTEGRATION TESTING

### âœ… MUST DO - Controller Integration Testing

```java
@SpringBootTest
@AutoConfigureMockMvc(addFilters = false)
@ActiveProfiles("test")
class UserControllerIntegrationTest extends BaseIntegrationTest {
    
    @Autowired
    private UserEntityRepository userRepository;
    
    @Test
    @DisplayName("íšŒì›ê°€ì… API ì„±ê³µ")
    void createUser_ValidRequest_ShouldReturn201() throws Exception {
        // given
        UserCreateRequest request = new UserCreateRequest(
            "test@example.com", 
            "Test User", 
            "password123!"
        );
        
        // when & then
        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.isSuccess").value(true))
            .andExpect(jsonPath("$.data.email").value("test@example.com"))
            .andExpect(jsonPath("$.data.name").value("Test User"));
        
        // Verify database state
        assertThat(userRepository.existsByEmail("test@example.com")).isTrue();
    }
    
    @Test
    @DisplayName("íšŒì›ê°€ì… API ì‹¤íŒ¨ - ì˜ëª»ëœ ì´ë©”ì¼ í˜•ì‹")
    void createUser_InvalidEmail_ShouldReturn400() throws Exception {
        // given
        UserCreateRequest request = new UserCreateRequest(
            "invalid-email", 
            "Test User", 
            "password123!"
        );
        
        // when & then
        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.code").value("C-001"))
            .andExpect(jsonPath("$.reason[0]").value("ì´ë©”ì¼ í˜•ì‹ìœ¼ë¡œ ìš”ì²­í•´ì£¼ì„¸ìš”."));
    }
}
```

### âœ… MUST DO - Authentication Testing

```java
@Test
@DisplayName("ì¸ì¦ëœ ì‚¬ìš©ì ìš”ì²­ ì„±ê³µ")
@WithCustomUser(email = "test@example.com")
void getUserInfo_AuthenticatedUser_ShouldReturnUserInfo() throws Exception {
    // given
    UserEntity user = ContextHolderUtil.getCurrentUser();
    
    // when & then
    mockMvc.perform(get("/api/users/me"))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.data.email").value(user.getEmail()));
}
```

### âŒ NEVER DO - Integration Test Violations

1. **NEVER** use mock objects in integration tests
2. **NEVER** skip database cleanup between tests
3. **NEVER** test only happy path scenarios
4. **NEVER** hardcode test data in integration tests
5. **NEVER** ignore test database configuration

## ğŸ“Š MANDATORY PARAMETERIZED TESTING

### âœ… MUST DO - Multiple Scenario Testing

```java
@ParameterizedTest(name = "[{index}] {0}")
@MethodSource("invalidUserCreateRequests")
@DisplayName("íšŒì›ê°€ì… ìš”ì²­ ì‹¤íŒ¨ - ì˜ëª»ëœ ì…ë ¥")
void createUser_InvalidRequest_ShouldReturn400(
    String description, 
    UserCreateRequest request, 
    String expectedErrorMessage) throws Exception {
    
    // when & then
    mockMvc.perform(post("/api/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(request)))
        .andExpect(status().isBadRequest())
        .andExpect(jsonPath("$.reason[0]").value(expectedErrorMessage));
}

static Stream<Arguments> invalidUserCreateRequests() {
    return Stream.of(
        Arguments.of(
            "ì´ë©”ì¼ì´ ë¹ˆ ë¬¸ìì—´ì¸ ê²½ìš°",
            new UserCreateRequest("", "Test User", "password123!"),
            "ì´ë©”ì¼ì€ í•„ìˆ˜ì…ë‹ˆë‹¤."
        ),
        Arguments.of(
            "ì´ë©”ì¼ í˜•ì‹ì´ ì˜ëª»ëœ ê²½ìš°",
            new UserCreateRequest("invalid-email", "Test User", "password123!"),
            "ì´ë©”ì¼ í˜•ì‹ìœ¼ë¡œ ìš”ì²­í•´ì£¼ì„¸ìš”."
        ),
        Arguments.of(
            "ì´ë¦„ì´ ë¹ˆ ë¬¸ìì—´ì¸ ê²½ìš°",
            new UserCreateRequest("test@example.com", "", "password123!"),
            "ì´ë¦„ì€ í•„ìˆ˜ì…ë‹ˆë‹¤."
        )
    );
}
```

### âœ… MUST DO - Test Data Factories

```java
// UserFactory.java
public class UserFactory {
    
    public static UserEntity createMockUser(Long id) {
        return UserEntity.builder()
            .id(id)
            .email("test" + id + "@example.com")
            .password("encodedPassword")
            .name("Test User " + id)
            .build();
    }
    
    public static UserEntity createMockUserWithoutId(String prefix) {
        return UserEntity.builder()
            .email(prefix + "@example.com")
            .password("encodedPassword")
            .name(prefix + " User")
            .build();
    }
}
```

### âŒ NEVER DO - Test Data Violations

1. **NEVER** hardcode test data in test methods
2. **NEVER** reuse test data between unrelated tests
3. **NEVER** create test data without proper cleanup
4. **NEVER** use production data in tests
5. **NEVER** ignore test data consistency

## ğŸ” MANDATORY TEST QUALITY RULES

### âœ… MUST DO - Test Quality Assurance

**Test Structure (AAA Pattern):**
```java
@Test
@DisplayName("í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ ì„¤ëª…")
void testMethod_scenario_expectedResult() {
    // given (Arrange)
    // í…ŒìŠ¤íŠ¸ ë°ì´í„° ë° ëª¨í‚¹ ì„¤ì •
    
    // when (Act)
    // í…ŒìŠ¤íŠ¸ ëŒ€ìƒ ë©”ì„œë“œ ì‹¤í–‰
    
    // then (Assert)
    // ê²°ê³¼ ê²€ì¦ ë° ëª¨í‚¹ ê²€ì¦
}
```

**Assertion Best Practices:**
```java
// âœ… GOOD - Use AssertJ for fluent assertions
assertThat(result).isNotNull();
assertThat(result.getEmail()).isEqualTo("test@example.com");
assertThat(result.getPosts()).hasSize(3);
assertThat(result.isActive()).isTrue();

// âœ… GOOD - Verify mock interactions
verify(userRepository).save(any(UserEntity.class));
verify(passwordEncoder).encode(password);
verifyNoMoreInteractions(userRepository);

// âŒ BAD - Don't use JUnit assertions
assertEquals("test@example.com", result.getEmail());
assertTrue(result.isActive());
```

### âœ… MUST DO - Test Coverage Requirements

1. **Service Layer**: 90%+ coverage
2. **Controller Layer**: 85%+ coverage
3. **Repository Layer**: 80%+ coverage
4. **Exception Handling**: 100% coverage
5. **Business Logic**: 95%+ coverage

### âŒ NEVER DO - Test Quality Violations

1. **NEVER** ignore flaky tests
2. **NEVER** create tests that depend on external services
3. **NEVER** use random data without controlling randomness
4. **NEVER** create tests that take longer than 5 seconds
5. **NEVER** skip testing edge cases
6. **NEVER** create tests without proper cleanup
7. **NEVER** use deprecated testing frameworks

## ğŸš¨ CRITICAL TESTING RULES

### âœ… MUST DO - Testing Checklist

Before committing tests, ensure:

âœ… All tests pass consistently
âœ… Test names clearly describe scenarios
âœ… Tests are independent and isolated
âœ… Mock objects are properly configured
âœ… Database state is cleaned between tests
âœ… Test data is realistic but not production data
âœ… Edge cases and error scenarios are covered
âœ… Performance tests exist for critical paths

### âŒ NEVER DO - Critical Test Violations

1. **Test Pollution** - Tests affecting each other
2. **Test Dependency** - Tests requiring specific execution order
3. **Test Duplication** - Testing same logic multiple times
4. **Test Complexity** - Tests that are hard to understand
5. **Test Neglect** - Broken tests left unfixed
6. **Test Shortage** - Critical paths without tests

## ğŸ“ˆ PERFORMANCE TESTING REQUIREMENTS

### âœ… MUST DO - Performance Test Examples

```java
@Test
@DisplayName("ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸")
void processLargeDataSet_ShouldCompleteWithinTimeLimit() {
    // given
    List<UserEntity> users = createLargeUserDataSet(10000);
    
    // when
    long startTime = System.currentTimeMillis();
    userService.processBatchUsers(users);
    long endTime = System.currentTimeMillis();
    
    // then
    long executionTime = endTime - startTime;
    assertThat(executionTime).isLessThan(5000); // 5ì´ˆ ì´ë‚´
}
```

Remember: **Tests are your safety net**. Write them first, write them well, and maintain them religiously!
# Testing Standards & Best Practices

## ğŸ§ª MANDATORY TESTING STRUCTURE

### âœ… MUST DO - Test Organization

**Test Package Structure:**
```
src/test/java/
â”œâ”€â”€ base/                           # Test utilities and base classes
â”‚   â”œâ”€â”€ BaseIntegrationTest.java   # Integration test base
â”‚   â”œâ”€â”€ BaseControllerTest.java    # Controller test base
â”‚   â”œâ”€â”€ TestUtil.java              # Test utilities
â”‚   â””â”€â”€ DatabaseCleanUp.java       # Database cleanup
â”œâ”€â”€ domain/                         # Domain layer tests
â”‚   â””â”€â”€ [domain]/
â”‚       â”œâ”€â”€ service/               # Service unit tests
â”‚       â”œâ”€â”€ repository/            # Repository integration tests
â”‚       â””â”€â”€ entityfactory/         # Test data factories
â””â”€â”€ web/                           # Web layer tests
    â””â”€â”€ [domain]/
        â””â”€â”€ controller/            # Controller integration tests
```

**Test Class Naming:**
- **Unit Tests**: `[ClassName]Test.java`
- **Integration Tests**: `[ClassName]IntegrationTest.java`
- **Controller Tests**: `[ClassName]ControllerTest.java`

### âœ… MUST DO - Test Method Naming

**Pattern**: `[methodName]_[scenario]_[expectedResult]`

```java
// âœ… GOOD Examples
@Test
@DisplayName("íšŒì›ê°€ì… ì„±ê³µ - ìœ íš¨í•œ ë°ì´í„°")
void createUser_ValidData_ShouldReturnUserCreateResponse() {
    // Test implementation
}

@Test
@DisplayName("íšŒì›ê°€ì… ì‹¤íŒ¨ - ì´ë©”ì¼ ì¤‘ë³µ")
void createUser_DuplicateEmail_ShouldThrowAppException() {
    // Test implementation
}

@Test
@DisplayName("ì‚¬ìš©ì ì¡°íšŒ ì‹¤íŒ¨ - ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ID")
void getUserById_NonExistentId_ShouldThrowUserNotFoundException() {
    // Test implementation
}
```

### âŒ NEVER DO - Test Structure Violations

1. **NEVER** put test classes in src/main/java
2. **NEVER** create tests without proper package structure
3. **NEVER** use generic test method names like `test1()`, `testMethod()`
4. **NEVER** skip `@DisplayName` annotation
5. **NEVER** mix different types of tests in the same class

## ğŸ¯ MANDATORY UNIT TESTING PATTERNS

### âœ… MUST DO - Service Layer Testing

```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @InjectMocks
    private UserService userService;
    
    @Mock
    private UserEntityRepository userRepository;
    
    @Mock
    private BCryptPasswordEncoder passwordEncoder;
    
    @Test
    @DisplayName("íšŒì›ê°€ì… ì„±ê³µ")
    void createUser_ValidData_ShouldReturnUserCreateResponse() {
        // given
        String email = "test@example.com";
        String password = "password123!";
        String name = "Test User";
        
        when(userRepository.existsByEmail(email)).thenReturn(false);
        when(passwordEncoder.encode(password)).thenReturn("encodedPassword");
        
        // when
        UserCreateResponse result = userService.createUser(email, password, name);
        
        // then
        assertThat(result).isNotNull();
        assertThat(result.email()).isEqualTo(email);
        assertThat(result.name()).isEqualTo(name);
        
        verify(userRepository).existsByEmail(email);
        verify(passwordEncoder).encode(password);
        verify(userRepository).save(any(UserEntity.class));
    }
    
    @Test
    @DisplayName("íšŒì›ê°€ì… ì‹¤íŒ¨ - ì´ë©”ì¼ ì¤‘ë³µ")
    void createUser_DuplicateEmail_ShouldThrowAppException() {
        // given
        String email = "duplicate@example.com";
        String password = "password123!";
        String name = "Test User";
        
        when(userRepository.existsByEmail(email)).thenReturn(true);
        
        // when & then
        AppException exception = assertThrows(AppException.class, 
            () -> userService.createUser(email, password, name));
        
        assertThat(exception.getErrorCode()).isEqualTo(ErrorCode.USER_EMAIL_DUPLICATED_EXCEPTION);
        
        verify(userRepository).existsByEmail(email);
        verify(passwordEncoder, never()).encode(any());
        verify(userRepository, never()).save(any());
    }
}
```

### âœ… MUST DO - Repository Testing

```java
@DataJpaTest
class UserEntityRepositoryTest {
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Autowired
    private UserEntityRepository userRepository;
    
    @Test
    @DisplayName("ì´ë©”ì¼ë¡œ ì‚¬ìš©ì ì¡°íšŒ ì„±ê³µ")
    void findByEmail_ExistingEmail_ShouldReturnUser() {
        // given
        UserEntity user = UserEntity.builder()
            .email("test@example.com")
            .password("password")
            .name("Test User")
            .build();
        entityManager.persistAndFlush(user);
        
        // when
        Optional<UserEntity> result = userRepository.findByEmail("test@example.com");
        
        // then
        assertThat(result).isPresent();
        assertThat(result.get().getEmail()).isEqualTo("test@example.com");
    }
}
```

### âŒ NEVER DO - Unit Test Violations

1. **NEVER** use real database in unit tests
2. **NEVER** test multiple scenarios in one test method
3. **NEVER** use `@SpringBootTest` for unit tests
4. **NEVER** ignore test failures
5. **NEVER** create tests without assertions

## ğŸŒ MANDATORY INTEGRATION TESTING

### âœ… MUST DO - Controller Integration Testing

```java
@SpringBootTest
@AutoConfigureMockMvc(addFilters = false)
@ActiveProfiles("test")
class UserControllerIntegrationTest extends BaseIntegrationTest {
    
    @Autowired
    private UserEntityRepository userRepository;
    
    @Test
    @DisplayName("íšŒì›ê°€ì… API ì„±ê³µ")
    void createUser_ValidRequest_ShouldReturn201() throws Exception {
        // given
        UserCreateRequest request = new UserCreateRequest(
            "test@example.com", 
            "Test User", 
            "password123!"
        );
        
        // when & then
        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.isSuccess").value(true))
            .andExpect(jsonPath("$.data.email").value("test@example.com"))
            .andExpect(jsonPath("$.data.name").value("Test User"));
        
        // Verify database state
        assertThat(userRepository.existsByEmail("test@example.com")).isTrue();
    }
    
    @Test
    @DisplayName("íšŒì›ê°€ì… API ì‹¤íŒ¨ - ì˜ëª»ëœ ì´ë©”ì¼ í˜•ì‹")
    void createUser_InvalidEmail_ShouldReturn400() throws Exception {
        // given
        UserCreateRequest request = new UserCreateRequest(
            "invalid-email", 
            "Test User", 
            "password123!"
        );
        
        // when & then
        mockMvc.perform(post("/api/users")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.code").value("C-001"))
            .andExpect(jsonPath("$.reason[0]").value("ì´ë©”ì¼ í˜•ì‹ìœ¼ë¡œ ìš”ì²­í•´ì£¼ì„¸ìš”."));
    }
}
```

### âœ… MUST DO - Authentication Testing

```java
@Test
@DisplayName("ì¸ì¦ëœ ì‚¬ìš©ì ìš”ì²­ ì„±ê³µ")
@WithCustomUser(email = "test@example.com")
void getUserInfo_AuthenticatedUser_ShouldReturnUserInfo() throws Exception {
    // given
    UserEntity user = ContextHolderUtil.getCurrentUser();
    
    // when & then
    mockMvc.perform(get("/api/users/me"))
        .andExpect(status().isOk())
        .andExpect(jsonPath("$.data.email").value(user.getEmail()));
}
```

### âŒ NEVER DO - Integration Test Violations

1. **NEVER** use mock objects in integration tests
2. **NEVER** skip database cleanup between tests
3. **NEVER** test only happy path scenarios
4. **NEVER** hardcode test data in integration tests
5. **NEVER** ignore test database configuration

## ğŸ“Š MANDATORY PARAMETERIZED TESTING

### âœ… MUST DO - Multiple Scenario Testing

```java
@ParameterizedTest(name = "[{index}] {0}")
@MethodSource("invalidUserCreateRequests")
@DisplayName("íšŒì›ê°€ì… ìš”ì²­ ì‹¤íŒ¨ - ì˜ëª»ëœ ì…ë ¥")
void createUser_InvalidRequest_ShouldReturn400(
    String description, 
    UserCreateRequest request, 
    String expectedErrorMessage) throws Exception {
    
    // when & then
    mockMvc.perform(post("/api/users")
            .contentType(MediaType.APPLICATION_JSON)
            .content(objectMapper.writeValueAsString(request)))
        .andExpect(status().isBadRequest())
        .andExpect(jsonPath("$.reason[0]").value(expectedErrorMessage));
}

static Stream<Arguments> invalidUserCreateRequests() {
    return Stream.of(
        Arguments.of(
            "ì´ë©”ì¼ì´ ë¹ˆ ë¬¸ìì—´ì¸ ê²½ìš°",
            new UserCreateRequest("", "Test User", "password123!"),
            "ì´ë©”ì¼ì€ í•„ìˆ˜ì…ë‹ˆë‹¤."
        ),
        Arguments.of(
            "ì´ë©”ì¼ í˜•ì‹ì´ ì˜ëª»ëœ ê²½ìš°",
            new UserCreateRequest("invalid-email", "Test User", "password123!"),
            "ì´ë©”ì¼ í˜•ì‹ìœ¼ë¡œ ìš”ì²­í•´ì£¼ì„¸ìš”."
        ),
        Arguments.of(
            "ì´ë¦„ì´ ë¹ˆ ë¬¸ìì—´ì¸ ê²½ìš°",
            new UserCreateRequest("test@example.com", "", "password123!"),
            "ì´ë¦„ì€ í•„ìˆ˜ì…ë‹ˆë‹¤."
        )
    );
}
```

### âœ… MUST DO - Test Data Factories

```java
// UserFactory.java
public class UserFactory {
    
    public static UserEntity createMockUser(Long id) {
        return UserEntity.builder()
            .id(id)
            .email("test" + id + "@example.com")
            .password("encodedPassword")
            .name("Test User " + id)
            .build();
    }
    
    public static UserEntity createMockUserWithoutId(String prefix) {
        return UserEntity.builder()
            .email(prefix + "@example.com")
            .password("encodedPassword")
            .name(prefix + " User")
            .build();
    }
}
```

### âŒ NEVER DO - Test Data Violations

1. **NEVER** hardcode test data in test methods
2. **NEVER** reuse test data between unrelated tests
3. **NEVER** create test data without proper cleanup
4. **NEVER** use production data in tests
5. **NEVER** ignore test data consistency

## ğŸ” MANDATORY TEST QUALITY RULES

### âœ… MUST DO - Test Quality Assurance

**Test Structure (AAA Pattern):**
```java
@Test
@DisplayName("í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤ ì„¤ëª…")
void testMethod_scenario_expectedResult() {
    // given (Arrange)
    // í…ŒìŠ¤íŠ¸ ë°ì´í„° ë° ëª¨í‚¹ ì„¤ì •
    
    // when (Act)
    // í…ŒìŠ¤íŠ¸ ëŒ€ìƒ ë©”ì„œë“œ ì‹¤í–‰
    
    // then (Assert)
    // ê²°ê³¼ ê²€ì¦ ë° ëª¨í‚¹ ê²€ì¦
}
```

**Assertion Best Practices:**
```java
// âœ… GOOD - Use AssertJ for fluent assertions
assertThat(result).isNotNull();
assertThat(result.getEmail()).isEqualTo("test@example.com");
assertThat(result.getPosts()).hasSize(3);
assertThat(result.isActive()).isTrue();

// âœ… GOOD - Verify mock interactions
verify(userRepository).save(any(UserEntity.class));
verify(passwordEncoder).encode(password);
verifyNoMoreInteractions(userRepository);

// âŒ BAD - Don't use JUnit assertions
assertEquals("test@example.com", result.getEmail());
assertTrue(result.isActive());
```

### âœ… MUST DO - Test Coverage Requirements

1. **Service Layer**: 90%+ coverage
2. **Controller Layer**: 85%+ coverage
3. **Repository Layer**: 80%+ coverage
4. **Exception Handling**: 100% coverage
5. **Business Logic**: 95%+ coverage

### âŒ NEVER DO - Test Quality Violations

1. **NEVER** ignore flaky tests
2. **NEVER** create tests that depend on external services
3. **NEVER** use random data without controlling randomness
4. **NEVER** create tests that take longer than 5 seconds
5. **NEVER** skip testing edge cases
6. **NEVER** create tests without proper cleanup
7. **NEVER** use deprecated testing frameworks

## ğŸš¨ CRITICAL TESTING RULES

### âœ… MUST DO - Testing Checklist

Before committing tests, ensure:

âœ… All tests pass consistently
âœ… Test names clearly describe scenarios
âœ… Tests are independent and isolated
âœ… Mock objects are properly configured
âœ… Database state is cleaned between tests
âœ… Test data is realistic but not production data
âœ… Edge cases and error scenarios are covered
âœ… Performance tests exist for critical paths

### âŒ NEVER DO - Critical Test Violations

1. **Test Pollution** - Tests affecting each other
2. **Test Dependency** - Tests requiring specific execution order
3. **Test Duplication** - Testing same logic multiple times
4. **Test Complexity** - Tests that are hard to understand
5. **Test Neglect** - Broken tests left unfixed
6. **Test Shortage** - Critical paths without tests

## ğŸ“ˆ PERFORMANCE TESTING REQUIREMENTS

### âœ… MUST DO - Performance Test Examples

```java
@Test
@DisplayName("ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸")
void processLargeDataSet_ShouldCompleteWithinTimeLimit() {
    // given
    List<UserEntity> users = createLargeUserDataSet(10000);
    
    // when
    long startTime = System.currentTimeMillis();
    userService.processBatchUsers(users);
    long endTime = System.currentTimeMillis();
    
    // then
    long executionTime = endTime - startTime;
    assertThat(executionTime).isLessThan(5000); // 5ì´ˆ ì´ë‚´
}
```

Remember: **Tests are your safety net**. Write them first, write them well, and maintain them religiously!
