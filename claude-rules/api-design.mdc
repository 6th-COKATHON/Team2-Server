---
alwaysApply: true
---

# API Design & Response Standards

## ğŸŒ MANDATORY API DESIGN PRINCIPLES

### âœ… MUST DO - RESTful API Design

**URL Structure:**
```
/api/[resource]                    # Collection
/api/[resource]/{id}               # Single resource
/api/[resource]/{id}/[sub-resource] # Sub-resource
```

**HTTP Methods:**
- **GET**: Retrieve data (idempotent)
- **POST**: Create new resource
- **PUT**: Update entire resource (idempotent)
- **PATCH**: Partial update
- **DELETE**: Remove resource (idempotent)

**Examples:**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping                    // GET /api/users
    public ResponseEntity<AppResponse<PageResponse<UserResponse>>> getUsers() { }
    
    @GetMapping("/{id}")           // GET /api/users/1
    public ResponseEntity<AppResponse<UserResponse>> getUser(@PathVariable Long id) { }
    
    @PostMapping                   // POST /api/users
    public ResponseEntity<AppResponse<UserCreateResponse>> createUser(@Valid @RequestBody UserCreateRequest request) { }
    
    @PutMapping("/{id}")           // PUT /api/users/1
    public ResponseEntity<AppResponse<UserUpdateResponse>> updateUser(@PathVariable Long id, @Valid @RequestBody UserUpdateRequest request) { }
    
    @DeleteMapping("/{id}")        // DELETE /api/users/1
    public ResponseEntity<AppResponse<Void>> deleteUser(@PathVariable Long id) { }
}
```

### âœ… MUST DO - HTTP Status Codes

**Standard Status Codes:**
- **200 OK**: Successful GET, PUT, PATCH
- **201 Created**: Successful POST
- **204 No Content**: Successful DELETE
- **400 Bad Request**: Invalid request data
- **401 Unauthorized**: Authentication required
- **403 Forbidden**: Access denied
- **404 Not Found**: Resource not found
- **409 Conflict**: Resource conflict (e.g., duplicate email)
- **422 Unprocessable Entity**: Validation failed
- **500 Internal Server Error**: Server error

### âŒ NEVER DO - API Design Violations

1. **NEVER** use verbs in URL paths (`/api/users/create` âŒ)
2. **NEVER** ignore HTTP method semantics
3. **NEVER** return different response formats for same endpoint
4. **NEVER** use non-standard HTTP status codes
5. **NEVER** expose internal implementation details in URLs
6. **NEVER** break REST principles for convenience

## ğŸ“ MANDATORY REQUEST/RESPONSE PATTERNS

### âœ… MUST DO - Request DTOs

**Request Validation:**
```java
public record UserCreateRequest(
    @Email(message = "ì´ë©”ì¼ í˜•ì‹ìœ¼ë¡œ ìš”ì²­í•´ì£¼ì„¸ìš”.")
    @NotBlank(message = "ì´ë©”ì¼ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    String email,
    
    @NotBlank(message = "ì´ë¦„ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    @Length(min = 2, max = 20, message = "ì´ë¦„ì€ 2ì ì´ìƒ 20ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    String name,
    
    @Password(message = "ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒ 20ì ì´í•˜, ì˜ë¬¸, ìˆ«ì, íŠ¹ìˆ˜ë¬¸ìë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.")
    String password
) {
    // Add static factory methods if needed
    public static UserCreateRequest of(String email, String name, String password) {
        return new UserCreateRequest(email, name, password);
    }
}
```

**Complex Request with Nested Objects:**
```java
public record PostCreateRequest(
    @NotBlank(message = "ì œëª©ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    @Length(max = 100, message = "ì œëª©ì€ 100ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    String title,
    
    @NotBlank(message = "ë‚´ìš©ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    @Length(max = 1000, message = "ë‚´ìš©ì€ 1000ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    String content,
    
    @Valid
    @NotNull(message = "ê°€ê²© ì •ë³´ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤.")
    PriceRequest price,
    
    @Valid
    @NotEmpty(message = "ì´ë¯¸ì§€ëŠ” ìµœì†Œ 1ê°œ ì´ìƒ í•„ìš”í•©ë‹ˆë‹¤.")
    @Size(max = 8, message = "ì´ë¯¸ì§€ëŠ” ìµœëŒ€ 8ê°œê¹Œì§€ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
    List<Long> imageIds
) {
    
    public record PriceRequest(
        @NotNull(message = "ì›ê°€ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤.")
        @Positive(message = "ì›ê°€ëŠ” ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.")
        Long originalPrice,
        
        @NotNull(message = "í• ì¸ê°€ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤.")
        @Positive(message = "í• ì¸ê°€ëŠ” ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.")
        Long discountPrice
    ) {}
}
```

### âœ… MUST DO - Response DTOs

**Standard Response Wrapper:**
```java
// Success Response
@JsonInclude(JsonInclude.Include.NON_NULL)
public class AppResponse<T> extends BaseResponse {
    private final T data;
    
    private AppResponse(HttpStatusCode status, T data) {
        super(true, status);
        this.data = data;
    }
    
    public static <T> AppResponse<T> ok(T data) {
        return new AppResponse<>(HttpStatus.OK, data);
    }
    
    public static <T> AppResponse<T> created(T data) {
        return new AppResponse<>(HttpStatus.CREATED, data);
    }
}
```

**Response DTO Pattern:**
```java
public record UserCreateResponse(
    Long id,
    String email,
    String name,
    LocalDateTime createdAt
) {
    public static UserCreateResponse from(UserEntity user) {
        return new UserCreateResponse(
            user.getId(),
            user.getEmail(),
            user.getName(),
            user.getCreateAt()
        );
    }
}
```

**Paginated Response:**
```java
public record PageResponse<T>(
    List<T> content,
    int page,
    int size,
    long totalElements,
    int totalPages,
    boolean first,
    boolean last
) {
    public static <T> PageResponse<T> of(Page<T> page) {
        return new PageResponse<>(
            page.getContent(),
            page.getNumber(),
            page.getSize(),
            page.getTotalElements(),
            page.getTotalPages(),
            page.isFirst(),
            page.isLast()
        );
    }
}
```

### âŒ NEVER DO - Request/Response Violations

1. **NEVER** use entities directly as request/response objects
2. **NEVER** expose internal field names in APIs
3. **NEVER** return inconsistent response formats
4. **NEVER** ignore validation on request objects
5. **NEVER** include sensitive data in responses
6. **NEVER** use different date formats in same API

## ğŸš¨ MANDATORY ERROR HANDLING

### âœ… MUST DO - Error Response Format

**Standard Error Response:**
```java
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse extends BaseResponse {
    private final String code;
    private final String message;
    private final List<String> reason;
    
    private ErrorResponse(ErrorCode errorCode, List<String> reason) {
        super(false, errorCode.getStatus());
        this.code = errorCode.getCode();
        this.message = errorCode.getMessage();
        this.reason = reason;
    }
    
    public static ErrorResponse of(ErrorCode errorCode) {
        return new ErrorResponse(errorCode, null);
    }
    
    public static ErrorResponse of(ErrorCode errorCode, List<String> reason) {
        return new ErrorResponse(errorCode, reason);
    }
}
```

**Global Exception Handler:**
```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorResponse> handleAppException(AppException e) {
        log.warn("Application exception occurred: {}", e.getMessage());
        return ResponseEntity
            .status(e.getErrorCode().getStatus())
            .body(ErrorResponse.of(e.getErrorCode()));
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException e) {
        List<String> errors = e.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(FieldError::getDefaultMessage)
            .collect(Collectors.toList());
            
        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(ErrorResponse.of(ErrorCode.USER_INPUT_EXCEPTION, errors));
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneralException(Exception e) {
        log.error("Unexpected error occurred", e);
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(ErrorResponse.of(ErrorCode.INTERNAL_SERVER_ERROR));
    }
}
```

### âœ… MUST DO - Error Code System

**Error Code Pattern:**
```java
public enum ErrorCode {
    // Common (C-xxx)
    USER_INPUT_EXCEPTION(HttpStatus.BAD_REQUEST, "C-001", "ì‚¬ìš©ì ì…ë ¥ ì˜¤ë¥˜"),
    AUTHENTICATION_EXCEPTION(HttpStatus.UNAUTHORIZED, "C-003", "ì¸ì¦ ì˜¤ë¥˜"),
    
    // User Domain (U-xxx)
    USER_NOT_FOUND_EXCEPTION(HttpStatus.NOT_FOUND, "U-002", "í•´ë‹¹ ìœ ì €ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."),
    USER_EMAIL_DUPLICATED_EXCEPTION(HttpStatus.CONFLICT, "U-001", "ì´ë¯¸ ì‚¬ìš©ì¤‘ì¸ ì´ë©”ì¼ì…ë‹ˆë‹¤."),
    
    // Post Domain (P-xxx)
    POST_NOT_FOUND_EXCEPTION(HttpStatus.NOT_FOUND, "P-001", "í•´ë‹¹ í¬ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."),
    POST_ROLE_EXCEPTION(HttpStatus.FORBIDDEN, "P-002", "í¬ìŠ¤íŠ¸ì— ëŒ€í•œ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.");
    
    private final HttpStatus status;
    private final String code;
    private final String message;
}
```

### âŒ NEVER DO - Error Handling Violations

1. **NEVER** return stack traces in production responses
2. **NEVER** use generic error messages
3. **NEVER** ignore exception logging
4. **NEVER** return different error formats
5. **NEVER** expose internal system information
6. **NEVER** use English in user-facing error messages

## ğŸ“– MANDATORY API DOCUMENTATION

### âœ… MUST DO - Swagger Documentation

**Controller Documentation:**
```java
@RestController
@RequestMapping("/api/users")
@Tag(name = "ì‚¬ìš©ì ê´€ë¦¬", description = "ì‚¬ìš©ì ê´€ë ¨ API")
public class UserController {
    
    @PostMapping
    @Operation(
        summary = "íšŒì›ê°€ì…",
        description = "ì´ë©”ì¼, ë¹„ë°€ë²ˆí˜¸, ì´ë¦„ì„ ì…ë ¥í•˜ì—¬ ìƒˆë¡œìš´ ì‚¬ìš©ìë¥¼ ìƒì„±í•©ë‹ˆë‹¤."
    )
    @ApiResponses({
        @ApiResponse(
            responseCode = "201",
            description = "íšŒì›ê°€ì… ì„±ê³µ",
            content = @Content(schema = @Schema(implementation = UserCreateResponse.class))
        ),
        @ApiResponse(
            responseCode = "400",
            description = "ì˜ëª»ëœ ìš”ì²­ ë°ì´í„°",
            content = @Content(schema = @Schema(implementation = ErrorResponse.class))
        ),
        @ApiResponse(
            responseCode = "409",
            description = "ì´ë¯¸ ì‚¬ìš©ì¤‘ì¸ ì´ë©”ì¼",
            content = @Content(schema = @Schema(implementation = ErrorResponse.class))
        )
    })
    public ResponseEntity<AppResponse<UserCreateResponse>> createUser(
        @Parameter(description = "ì‚¬ìš©ì ìƒì„± ìš”ì²­ ì •ë³´", required = true)
        @Valid @RequestBody UserCreateRequest request) {
        
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(AppResponse.created(userService.createUser(request)));
    }
}
```

**DTO Documentation:**
```java
@Schema(description = "ì‚¬ìš©ì ìƒì„± ìš”ì²­")
public record UserCreateRequest(
    @Schema(description = "ì´ë©”ì¼ ì£¼ì†Œ", example = "user@example.com")
    @Email(message = "ì´ë©”ì¼ í˜•ì‹ìœ¼ë¡œ ìš”ì²­í•´ì£¼ì„¸ìš”.")
    @NotBlank(message = "ì´ë©”ì¼ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    String email,
    
    @Schema(description = "ì‚¬ìš©ì ì´ë¦„", example = "í™ê¸¸ë™")
    @NotBlank(message = "ì´ë¦„ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    @Length(min = 2, max = 20, message = "ì´ë¦„ì€ 2ì ì´ìƒ 20ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    String name,
    
    @Schema(description = "ë¹„ë°€ë²ˆí˜¸", example = "password123!")
    @Password(message = "ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒ 20ì ì´í•˜, ì˜ë¬¸, ìˆ«ì, íŠ¹ìˆ˜ë¬¸ìë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.")
    String password
) {}
```

### âŒ NEVER DO - Documentation Violations

1. **NEVER** leave APIs without documentation
2. **NEVER** use English in Korean service descriptions
3. **NEVER** forget to update documentation when changing APIs
4. **NEVER** include internal implementation details
5. **NEVER** use meaningless examples in documentation

## ğŸ” MANDATORY SECURITY PATTERNS

### âœ… MUST DO - Authentication & Authorization

**Authentication Annotation:**
```java
@GetMapping("/me")
@Operation(summary = "í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ")
public ResponseEntity<AppResponse<UserInfoResponse>> getCurrentUser(
    @Parameter(hidden = true) @CurrentUser UserEntity user) {
    
    return ResponseEntity.ok(AppResponse.ok(userService.getUserInfo(user)));
}
```

**Authorization Checks:**
```java
@DeleteMapping("/{id}")
@Operation(summary = "ê²Œì‹œë¬¼ ì‚­ì œ")
public ResponseEntity<AppResponse<Void>> deletePost(
    @PathVariable Long id,
    @CurrentUser UserEntity user) {
    
    // Business logic handles authorization
    postService.deletePost(id, user);
    
    return ResponseEntity.ok(AppResponse.noContent());
}
```

### âœ… MUST DO - Input Validation

**Request Body Validation:**
```java
@PostMapping
public ResponseEntity<AppResponse<PostCreateResponse>> createPost(
    @Valid @RequestBody PostCreateRequest request,  // Always use @Valid
    @CurrentUser UserEntity user) {
    
    return ResponseEntity.status(HttpStatus.CREATED)
        .body(AppResponse.created(postService.createPost(request, user)));
}
```

**Path Variable Validation:**
```java
@GetMapping("/{id}")
public ResponseEntity<AppResponse<PostResponse>> getPost(
    @PathVariable @Positive(message = "ê²Œì‹œë¬¼ IDëŠ” ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.") Long id) {
    
    return ResponseEntity.ok(AppResponse.ok(postService.getPost(id)));
}
```

### âŒ NEVER DO - Security Violations

1. **NEVER** skip input validation
2. **NEVER** trust client-provided data
3. **NEVER** expose sensitive information in responses
4. **NEVER** implement authorization in controllers
5. **NEVER** log sensitive data
6. **NEVER** use HTTP for sensitive operations

## ğŸ”„ MANDATORY API VERSIONING

### âœ… MUST DO - API Version Management

**URL Path Versioning:**
```java
@RestController
@RequestMapping("/api/v1/users")  // Version in URL path
public class UserControllerV1 {
    // Implementation
}

@RestController
@RequestMapping("/api/v2/users")
public class UserControllerV2 {
    // Implementation
}
```

**Deprecation Handling:**
```java
@GetMapping("/deprecated-endpoint")
@Operation(summary = "êµ¬ë²„ì „ API", deprecated = true)
@Deprecated
public ResponseEntity<AppResponse<OldResponse>> oldEndpoint() {
    log.warn("Deprecated API called: /api/v1/users/deprecated-endpoint");
    // Implementation
}
```

### âŒ NEVER DO - Versioning Violations

1. **NEVER** break backward compatibility without notice
2. **NEVER** remove APIs without deprecation period
3. **NEVER** change response formats in same version
4. **NEVER** ignore version management
5. **NEVER** mix different versioning strategies

## ğŸš¨ CRITICAL API QUALITY RULES

### âœ… MUST DO - API Quality Checklist

Before deploying APIs, ensure:

âœ… All endpoints have proper HTTP methods
âœ… Response formats are consistent
âœ… Error handling is comprehensive
âœ… Input validation is complete
âœ… Authentication/authorization is implemented
âœ… API documentation is up-to-date
âœ… Performance is acceptable
âœ… Security is verified

### âŒ NEVER DO - Critical API Violations

1. **Inconsistent Response Formats** - Always use standard wrappers
2. **Missing Error Handling** - Every endpoint must handle errors
3. **Poor Performance** - APIs must respond within 2 seconds
4. **Security Gaps** - Never skip authentication/authorization
5. **Undocumented Changes** - Always update documentation
6. **Breaking Changes** - Never break existing integrations

## ğŸ“Š PERFORMANCE REQUIREMENTS

### âœ… MUST DO - Performance Standards

**Response Time Limits:**
- **Simple GET requests**: < 200ms
- **Complex queries**: < 1000ms
- **Create/Update operations**: < 2000ms
- **File uploads**: < 5000ms

**Pagination Requirements:**
```java
@GetMapping
public ResponseEntity<AppResponse<PageResponse<PostResponse>>> getPosts(
    @RequestParam(defaultValue = "0") @Min(0) int page,
    @RequestParam(defaultValue = "10") @Min(1) @Max(100) int size,
    @RequestParam(defaultValue = "createdAt") String sort) {
    
    return ResponseEntity.ok(AppResponse.ok(postService.getPosts(page, size, sort)));
}
```

### âŒ NEVER DO - Performance Violations

1. **NEVER** return unbounded result sets
2. **NEVER** ignore database query optimization
3. **NEVER** perform heavy operations in controllers
4. **NEVER** skip caching for expensive operations
5. **NEVER** ignore memory usage in large responses

Remember: **APIs are contracts**. Design them carefully, document them thoroughly, and maintain them religiously!
# API Design & Response Standards

## ğŸŒ MANDATORY API DESIGN PRINCIPLES

### âœ… MUST DO - RESTful API Design

**URL Structure:**
```
/api/[resource]                    # Collection
/api/[resource]/{id}               # Single resource
/api/[resource]/{id}/[sub-resource] # Sub-resource
```

**HTTP Methods:**
- **GET**: Retrieve data (idempotent)
- **POST**: Create new resource
- **PUT**: Update entire resource (idempotent)
- **PATCH**: Partial update
- **DELETE**: Remove resource (idempotent)

**Examples:**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping                    // GET /api/users
    public ResponseEntity<AppResponse<PageResponse<UserResponse>>> getUsers() { }
    
    @GetMapping("/{id}")           // GET /api/users/1
    public ResponseEntity<AppResponse<UserResponse>> getUser(@PathVariable Long id) { }
    
    @PostMapping                   // POST /api/users
    public ResponseEntity<AppResponse<UserCreateResponse>> createUser(@Valid @RequestBody UserCreateRequest request) { }
    
    @PutMapping("/{id}")           // PUT /api/users/1
    public ResponseEntity<AppResponse<UserUpdateResponse>> updateUser(@PathVariable Long id, @Valid @RequestBody UserUpdateRequest request) { }
    
    @DeleteMapping("/{id}")        // DELETE /api/users/1
    public ResponseEntity<AppResponse<Void>> deleteUser(@PathVariable Long id) { }
}
```

### âœ… MUST DO - HTTP Status Codes

**Standard Status Codes:**
- **200 OK**: Successful GET, PUT, PATCH
- **201 Created**: Successful POST
- **204 No Content**: Successful DELETE
- **400 Bad Request**: Invalid request data
- **401 Unauthorized**: Authentication required
- **403 Forbidden**: Access denied
- **404 Not Found**: Resource not found
- **409 Conflict**: Resource conflict (e.g., duplicate email)
- **422 Unprocessable Entity**: Validation failed
- **500 Internal Server Error**: Server error

### âŒ NEVER DO - API Design Violations

1. **NEVER** use verbs in URL paths (`/api/users/create` âŒ)
2. **NEVER** ignore HTTP method semantics
3. **NEVER** return different response formats for same endpoint
4. **NEVER** use non-standard HTTP status codes
5. **NEVER** expose internal implementation details in URLs
6. **NEVER** break REST principles for convenience

## ğŸ“ MANDATORY REQUEST/RESPONSE PATTERNS

### âœ… MUST DO - Request DTOs

**Request Validation:**
```java
public record UserCreateRequest(
    @Email(message = "ì´ë©”ì¼ í˜•ì‹ìœ¼ë¡œ ìš”ì²­í•´ì£¼ì„¸ìš”.")
    @NotBlank(message = "ì´ë©”ì¼ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    String email,
    
    @NotBlank(message = "ì´ë¦„ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    @Length(min = 2, max = 20, message = "ì´ë¦„ì€ 2ì ì´ìƒ 20ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    String name,
    
    @Password(message = "ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒ 20ì ì´í•˜, ì˜ë¬¸, ìˆ«ì, íŠ¹ìˆ˜ë¬¸ìë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.")
    String password
) {
    // Add static factory methods if needed
    public static UserCreateRequest of(String email, String name, String password) {
        return new UserCreateRequest(email, name, password);
    }
}
```

**Complex Request with Nested Objects:**
```java
public record PostCreateRequest(
    @NotBlank(message = "ì œëª©ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    @Length(max = 100, message = "ì œëª©ì€ 100ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    String title,
    
    @NotBlank(message = "ë‚´ìš©ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    @Length(max = 1000, message = "ë‚´ìš©ì€ 1000ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    String content,
    
    @Valid
    @NotNull(message = "ê°€ê²© ì •ë³´ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤.")
    PriceRequest price,
    
    @Valid
    @NotEmpty(message = "ì´ë¯¸ì§€ëŠ” ìµœì†Œ 1ê°œ ì´ìƒ í•„ìš”í•©ë‹ˆë‹¤.")
    @Size(max = 8, message = "ì´ë¯¸ì§€ëŠ” ìµœëŒ€ 8ê°œê¹Œì§€ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
    List<Long> imageIds
) {
    
    public record PriceRequest(
        @NotNull(message = "ì›ê°€ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤.")
        @Positive(message = "ì›ê°€ëŠ” ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.")
        Long originalPrice,
        
        @NotNull(message = "í• ì¸ê°€ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤.")
        @Positive(message = "í• ì¸ê°€ëŠ” ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.")
        Long discountPrice
    ) {}
}
```

### âœ… MUST DO - Response DTOs

**Standard Response Wrapper:**
```java
// Success Response
@JsonInclude(JsonInclude.Include.NON_NULL)
public class AppResponse<T> extends BaseResponse {
    private final T data;
    
    private AppResponse(HttpStatusCode status, T data) {
        super(true, status);
        this.data = data;
    }
    
    public static <T> AppResponse<T> ok(T data) {
        return new AppResponse<>(HttpStatus.OK, data);
    }
    
    public static <T> AppResponse<T> created(T data) {
        return new AppResponse<>(HttpStatus.CREATED, data);
    }
}
```

**Response DTO Pattern:**
```java
public record UserCreateResponse(
    Long id,
    String email,
    String name,
    LocalDateTime createdAt
) {
    public static UserCreateResponse from(UserEntity user) {
        return new UserCreateResponse(
            user.getId(),
            user.getEmail(),
            user.getName(),
            user.getCreateAt()
        );
    }
}
```

**Paginated Response:**
```java
public record PageResponse<T>(
    List<T> content,
    int page,
    int size,
    long totalElements,
    int totalPages,
    boolean first,
    boolean last
) {
    public static <T> PageResponse<T> of(Page<T> page) {
        return new PageResponse<>(
            page.getContent(),
            page.getNumber(),
            page.getSize(),
            page.getTotalElements(),
            page.getTotalPages(),
            page.isFirst(),
            page.isLast()
        );
    }
}
```

### âŒ NEVER DO - Request/Response Violations

1. **NEVER** use entities directly as request/response objects
2. **NEVER** expose internal field names in APIs
3. **NEVER** return inconsistent response formats
4. **NEVER** ignore validation on request objects
5. **NEVER** include sensitive data in responses
6. **NEVER** use different date formats in same API

## ğŸš¨ MANDATORY ERROR HANDLING

### âœ… MUST DO - Error Response Format

**Standard Error Response:**
```java
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ErrorResponse extends BaseResponse {
    private final String code;
    private final String message;
    private final List<String> reason;
    
    private ErrorResponse(ErrorCode errorCode, List<String> reason) {
        super(false, errorCode.getStatus());
        this.code = errorCode.getCode();
        this.message = errorCode.getMessage();
        this.reason = reason;
    }
    
    public static ErrorResponse of(ErrorCode errorCode) {
        return new ErrorResponse(errorCode, null);
    }
    
    public static ErrorResponse of(ErrorCode errorCode, List<String> reason) {
        return new ErrorResponse(errorCode, reason);
    }
}
```

**Global Exception Handler:**
```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    @ExceptionHandler(AppException.class)
    public ResponseEntity<ErrorResponse> handleAppException(AppException e) {
        log.warn("Application exception occurred: {}", e.getMessage());
        return ResponseEntity
            .status(e.getErrorCode().getStatus())
            .body(ErrorResponse.of(e.getErrorCode()));
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException e) {
        List<String> errors = e.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(FieldError::getDefaultMessage)
            .collect(Collectors.toList());
            
        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(ErrorResponse.of(ErrorCode.USER_INPUT_EXCEPTION, errors));
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneralException(Exception e) {
        log.error("Unexpected error occurred", e);
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(ErrorResponse.of(ErrorCode.INTERNAL_SERVER_ERROR));
    }
}
```

### âœ… MUST DO - Error Code System

**Error Code Pattern:**
```java
public enum ErrorCode {
    // Common (C-xxx)
    USER_INPUT_EXCEPTION(HttpStatus.BAD_REQUEST, "C-001", "ì‚¬ìš©ì ì…ë ¥ ì˜¤ë¥˜"),
    AUTHENTICATION_EXCEPTION(HttpStatus.UNAUTHORIZED, "C-003", "ì¸ì¦ ì˜¤ë¥˜"),
    
    // User Domain (U-xxx)
    USER_NOT_FOUND_EXCEPTION(HttpStatus.NOT_FOUND, "U-002", "í•´ë‹¹ ìœ ì €ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."),
    USER_EMAIL_DUPLICATED_EXCEPTION(HttpStatus.CONFLICT, "U-001", "ì´ë¯¸ ì‚¬ìš©ì¤‘ì¸ ì´ë©”ì¼ì…ë‹ˆë‹¤."),
    
    // Post Domain (P-xxx)
    POST_NOT_FOUND_EXCEPTION(HttpStatus.NOT_FOUND, "P-001", "í•´ë‹¹ í¬ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."),
    POST_ROLE_EXCEPTION(HttpStatus.FORBIDDEN, "P-002", "í¬ìŠ¤íŠ¸ì— ëŒ€í•œ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.");
    
    private final HttpStatus status;
    private final String code;
    private final String message;
}
```

### âŒ NEVER DO - Error Handling Violations

1. **NEVER** return stack traces in production responses
2. **NEVER** use generic error messages
3. **NEVER** ignore exception logging
4. **NEVER** return different error formats
5. **NEVER** expose internal system information
6. **NEVER** use English in user-facing error messages

## ğŸ“– MANDATORY API DOCUMENTATION

### âœ… MUST DO - Swagger Documentation

**Controller Documentation:**
```java
@RestController
@RequestMapping("/api/users")
@Tag(name = "ì‚¬ìš©ì ê´€ë¦¬", description = "ì‚¬ìš©ì ê´€ë ¨ API")
public class UserController {
    
    @PostMapping
    @Operation(
        summary = "íšŒì›ê°€ì…",
        description = "ì´ë©”ì¼, ë¹„ë°€ë²ˆí˜¸, ì´ë¦„ì„ ì…ë ¥í•˜ì—¬ ìƒˆë¡œìš´ ì‚¬ìš©ìë¥¼ ìƒì„±í•©ë‹ˆë‹¤."
    )
    @ApiResponses({
        @ApiResponse(
            responseCode = "201",
            description = "íšŒì›ê°€ì… ì„±ê³µ",
            content = @Content(schema = @Schema(implementation = UserCreateResponse.class))
        ),
        @ApiResponse(
            responseCode = "400",
            description = "ì˜ëª»ëœ ìš”ì²­ ë°ì´í„°",
            content = @Content(schema = @Schema(implementation = ErrorResponse.class))
        ),
        @ApiResponse(
            responseCode = "409",
            description = "ì´ë¯¸ ì‚¬ìš©ì¤‘ì¸ ì´ë©”ì¼",
            content = @Content(schema = @Schema(implementation = ErrorResponse.class))
        )
    })
    public ResponseEntity<AppResponse<UserCreateResponse>> createUser(
        @Parameter(description = "ì‚¬ìš©ì ìƒì„± ìš”ì²­ ì •ë³´", required = true)
        @Valid @RequestBody UserCreateRequest request) {
        
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(AppResponse.created(userService.createUser(request)));
    }
}
```

**DTO Documentation:**
```java
@Schema(description = "ì‚¬ìš©ì ìƒì„± ìš”ì²­")
public record UserCreateRequest(
    @Schema(description = "ì´ë©”ì¼ ì£¼ì†Œ", example = "user@example.com")
    @Email(message = "ì´ë©”ì¼ í˜•ì‹ìœ¼ë¡œ ìš”ì²­í•´ì£¼ì„¸ìš”.")
    @NotBlank(message = "ì´ë©”ì¼ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    String email,
    
    @Schema(description = "ì‚¬ìš©ì ì´ë¦„", example = "í™ê¸¸ë™")
    @NotBlank(message = "ì´ë¦„ì€ í•„ìˆ˜ì…ë‹ˆë‹¤.")
    @Length(min = 2, max = 20, message = "ì´ë¦„ì€ 2ì ì´ìƒ 20ì ì´í•˜ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    String name,
    
    @Schema(description = "ë¹„ë°€ë²ˆí˜¸", example = "password123!")
    @Password(message = "ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒ 20ì ì´í•˜, ì˜ë¬¸, ìˆ«ì, íŠ¹ìˆ˜ë¬¸ìë¥¼ í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.")
    String password
) {}
```

### âŒ NEVER DO - Documentation Violations

1. **NEVER** leave APIs without documentation
2. **NEVER** use English in Korean service descriptions
3. **NEVER** forget to update documentation when changing APIs
4. **NEVER** include internal implementation details
5. **NEVER** use meaningless examples in documentation

## ğŸ” MANDATORY SECURITY PATTERNS

### âœ… MUST DO - Authentication & Authorization

**Authentication Annotation:**
```java
@GetMapping("/me")
@Operation(summary = "í˜„ì¬ ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ")
public ResponseEntity<AppResponse<UserInfoResponse>> getCurrentUser(
    @Parameter(hidden = true) @CurrentUser UserEntity user) {
    
    return ResponseEntity.ok(AppResponse.ok(userService.getUserInfo(user)));
}
```

**Authorization Checks:**
```java
@DeleteMapping("/{id}")
@Operation(summary = "ê²Œì‹œë¬¼ ì‚­ì œ")
public ResponseEntity<AppResponse<Void>> deletePost(
    @PathVariable Long id,
    @CurrentUser UserEntity user) {
    
    // Business logic handles authorization
    postService.deletePost(id, user);
    
    return ResponseEntity.ok(AppResponse.noContent());
}
```

### âœ… MUST DO - Input Validation

**Request Body Validation:**
```java
@PostMapping
public ResponseEntity<AppResponse<PostCreateResponse>> createPost(
    @Valid @RequestBody PostCreateRequest request,  // Always use @Valid
    @CurrentUser UserEntity user) {
    
    return ResponseEntity.status(HttpStatus.CREATED)
        .body(AppResponse.created(postService.createPost(request, user)));
}
```

**Path Variable Validation:**
```java
@GetMapping("/{id}")
public ResponseEntity<AppResponse<PostResponse>> getPost(
    @PathVariable @Positive(message = "ê²Œì‹œë¬¼ IDëŠ” ì–‘ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.") Long id) {
    
    return ResponseEntity.ok(AppResponse.ok(postService.getPost(id)));
}
```

### âŒ NEVER DO - Security Violations

1. **NEVER** skip input validation
2. **NEVER** trust client-provided data
3. **NEVER** expose sensitive information in responses
4. **NEVER** implement authorization in controllers
5. **NEVER** log sensitive data
6. **NEVER** use HTTP for sensitive operations

## ğŸ”„ MANDATORY API VERSIONING

### âœ… MUST DO - API Version Management

**URL Path Versioning:**
```java
@RestController
@RequestMapping("/api/v1/users")  // Version in URL path
public class UserControllerV1 {
    // Implementation
}

@RestController
@RequestMapping("/api/v2/users")
public class UserControllerV2 {
    // Implementation
}
```

**Deprecation Handling:**
```java
@GetMapping("/deprecated-endpoint")
@Operation(summary = "êµ¬ë²„ì „ API", deprecated = true)
@Deprecated
public ResponseEntity<AppResponse<OldResponse>> oldEndpoint() {
    log.warn("Deprecated API called: /api/v1/users/deprecated-endpoint");
    // Implementation
}
```

### âŒ NEVER DO - Versioning Violations

1. **NEVER** break backward compatibility without notice
2. **NEVER** remove APIs without deprecation period
3. **NEVER** change response formats in same version
4. **NEVER** ignore version management
5. **NEVER** mix different versioning strategies

## ğŸš¨ CRITICAL API QUALITY RULES

### âœ… MUST DO - API Quality Checklist

Before deploying APIs, ensure:

âœ… All endpoints have proper HTTP methods
âœ… Response formats are consistent
âœ… Error handling is comprehensive
âœ… Input validation is complete
âœ… Authentication/authorization is implemented
âœ… API documentation is up-to-date
âœ… Performance is acceptable
âœ… Security is verified

### âŒ NEVER DO - Critical API Violations

1. **Inconsistent Response Formats** - Always use standard wrappers
2. **Missing Error Handling** - Every endpoint must handle errors
3. **Poor Performance** - APIs must respond within 2 seconds
4. **Security Gaps** - Never skip authentication/authorization
5. **Undocumented Changes** - Always update documentation
6. **Breaking Changes** - Never break existing integrations

## ğŸ“Š PERFORMANCE REQUIREMENTS

### âœ… MUST DO - Performance Standards

**Response Time Limits:**
- **Simple GET requests**: < 200ms
- **Complex queries**: < 1000ms
- **Create/Update operations**: < 2000ms
- **File uploads**: < 5000ms

**Pagination Requirements:**
```java
@GetMapping
public ResponseEntity<AppResponse<PageResponse<PostResponse>>> getPosts(
    @RequestParam(defaultValue = "0") @Min(0) int page,
    @RequestParam(defaultValue = "10") @Min(1) @Max(100) int size,
    @RequestParam(defaultValue = "createdAt") String sort) {
    
    return ResponseEntity.ok(AppResponse.ok(postService.getPosts(page, size, sort)));
}
```

### âŒ NEVER DO - Performance Violations

1. **NEVER** return unbounded result sets
2. **NEVER** ignore database query optimization
3. **NEVER** perform heavy operations in controllers
4. **NEVER** skip caching for expensive operations
5. **NEVER** ignore memory usage in large responses

Remember: **APIs are contracts**. Design them carefully, document them thoroughly, and maintain them religiously!
